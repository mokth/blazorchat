@inject IJSRuntime JSRuntime

<div class="message-input-container">
    @if (isUploading)
    {
        <div class="upload-progress">
            <span class="spinner-border spinner-border-sm"></span>
            <span class="ms-2">Uploading...</span>
        </div>
    }
    <div class="input-actions">
        <button class="btn-icon" @onclick="HandleImageUpload" title="Send image" disabled="@isUploading">
            üì∑
        </button>
        <button class="btn-icon"
                title="Hold to record voice"
                @onpointerdown="HandleVoicePress"
                @onpointerup="HandleVoiceRelease"
                @onpointerleave="HandleVoiceRelease"
                @onpointercancel="HandleVoiceRelease"
                @onkeydown="HandleVoiceKeyDown"
                @onkeyup="HandleVoiceKeyUp">
        <button class="btn-icon" @onclick="ToggleVoiceRecorder" title="Record voice" disabled="@isUploading">
            @if (isRecording)
            {
                <span>‚èπÔ∏è</span>
            }
            else
            {
                <span>üé§</span>
            }
        </button>
        <button class="btn-icon" @onclick="HandleFileUpload" title="Attach file" disabled="@isUploading">
            üìé
        </button>
    </div>

    <input type="file" @ref="imageInputRef" style="display:none" accept="image/*" @onchange="OnImageSelected" />
    <input type="file" @ref="fileInputRef" style="display:none" @onchange="OnFileSelected" />

    @if (isRecording)
    {
        <div class="recording-indicator">
            <span class="recording-dot"></span>
            Recording... @recordingDuration s
        </div>
    }
    else
    {
        <input type="text" 
               class="message-input" 
               placeholder="Type a message..." 
               @bind="currentMessage" 
               @bind:event="oninput"
               @onkeydown="HandleKeyDown" />
    }

    <button class="btn-send" @onclick="SendCurrentMessage" disabled="@(string.IsNullOrWhiteSpace(currentMessage) && !isRecording)">
        ‚û§
    </button>
</div>

@code {
    [Parameter] public EventCallback<string> OnSendMessage { get; set; }
    [Parameter] public EventCallback<(string imageData, string fileName)> OnSendImage { get; set; }
    [Parameter] public EventCallback<(string audioData, int duration)> OnSendVoice { get; set; }
    [Parameter] public EventCallback<(string fileData, string fileName)> OnSendFile { get; set; }
    [Parameter] public EventCallback OnTyping { get; set; }

    private string currentMessage = "";
    private ElementReference imageInputRef;
    private ElementReference fileInputRef;
    private bool isRecording = false;
    private bool isRecordingRequested = false;
    private bool stopRequested = false;
    private int recordingDuration = 0;
    private bool isUploading = false;
    private System.Threading.Timer? recordingTimer;

    private async Task SendCurrentMessage()
    {
        if (!string.IsNullOrWhiteSpace(currentMessage))
        {
            await OnSendMessage.InvokeAsync(currentMessage);
            currentMessage = "";
        }
    }

    private async Task HandleKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "Enter" && !e.ShiftKey)
        {
            await SendCurrentMessage();
        }
        else
        {
            // Trigger typing indicator on any key press
            await OnTyping.InvokeAsync();
        }
    }

    private async Task HandleImageUpload()
    {
        await JSRuntime.InvokeVoidAsync("triggerFileInput", imageInputRef);
    }

    private async Task HandleFileUpload()
    {
        await JSRuntime.InvokeVoidAsync("triggerFileInput", fileInputRef);
    }

    private async Task OnImageSelected(ChangeEventArgs e)
    {
        isUploading = true;
        StateHasChanged();

        try
        {
            var result = await JSRuntime.InvokeAsync<string>("readFileAsBase64", imageInputRef);
            if (!string.IsNullOrEmpty(result))
            {
                var parts = result.Split('|');
                if (parts.Length == 2)
                {
                    await OnSendImage.InvokeAsync((parts[0], parts[1]));
                }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error reading image: {ex.Message}");
        }
        finally
        {
            isUploading = false;
            StateHasChanged();
        }
    }

    private async Task OnFileSelected(ChangeEventArgs e)
    {
        isUploading = true;
        StateHasChanged();

        try
        {
            var result = await JSRuntime.InvokeAsync<string>("readFileAsBase64", fileInputRef);
            if (!string.IsNullOrEmpty(result))
            {
                var parts = result.Split('|');
                if (parts.Length == 2)
                {
                    await OnSendFile.InvokeAsync((parts[0], parts[1]));
                }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error reading file: {ex.Message}");
        }
        finally
        {
            isUploading = false;
            StateHasChanged();
        }
    }

    private async Task StartRecording()
    {
        if (isRecording)
        {
            return;
        }

        var started = await JSRuntime.InvokeAsync<bool>("startVoiceRecording");
        if (!started)
        {
            isRecordingRequested = false;
            stopRequested = false;
            isRecording = false;
            return;
        }

        isRecording = true;
        recordingDuration = 0;
        
        recordingTimer = new System.Threading.Timer(_ =>
        {
            recordingDuration++;
            InvokeAsync(StateHasChanged);
            
            // Auto-stop after 2 minutes
            if (recordingDuration >= 120)
            {
                InvokeAsync(StopRecording);
            }
        }, null, 1000, 1000);

        if (!isRecordingRequested || stopRequested)
        {
            await StopRecording();
        }
    }

    private async Task StopRecording()
    {
        if (!isRecording)
        {
            return;
        }

        isRecording = false;
        isRecordingRequested = false;
        stopRequested = false;
        recordingTimer?.Dispose();
        
        var audioData = await JSRuntime.InvokeAsync<string>("stopVoiceRecording");
        if (!string.IsNullOrEmpty(audioData))
        {
            await OnSendVoice.InvokeAsync((audioData, recordingDuration));
        }
        
        recordingDuration = 0;
    }

    private async Task HandleVoicePress()
    {
        if (isRecordingRequested)
        {
            return;
        }

        isRecordingRequested = true;
        stopRequested = false;
        await StartRecording();
    }

    private async Task HandleVoiceRelease()
    {
        isRecordingRequested = false;

        if (isRecording)
        {
            await StopRecording();
            return;
        }

        stopRequested = true;
    }

    private async Task HandleVoiceKeyDown(KeyboardEventArgs e)
    {
        if (e.Key is " " or "Enter")
        {
            await HandleVoicePress();
        }
    }

    private async Task HandleVoiceKeyUp(KeyboardEventArgs e)
    {
        if (e.Key is " " or "Enter")
        {
            await HandleVoiceRelease();
        }
    }
}
